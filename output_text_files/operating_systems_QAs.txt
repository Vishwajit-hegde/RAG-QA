Q: What is the main goal of an operating system, and what are the different types of operating systems that exist?
A: The main goal of an operating system is to manage computer hardware resources and provide a platform for running application software. The different types of operating systems include single-process operating systems, batch processing operating systems, multiprogramming operating systems, multitasking operating systems, multi-processing operating systems, distributed systems, real-time operating systems, and embedded systems.
Context: UNIT	 1	 AN	INTRODUCTION 	TO	OPERATING	 SYSTEMS 	 Application	 software	 performs 	specific 	task	for	the	 user.	 System	software	 operates	and	controls	the	computer	 system	and 	provides	a	platform	to	run 	 application 	software. 	 An	operating 	system 	is	a	piece 	of	software	 that	 manages 	all	the	resources 	of	a	computer 	 system, 	both	 hardware	 and	 software,	 and	 provides	 an	 environment	 in	 which	 the	 user	 can	 execute	 his/her 	programs	 in	a	convenient 	and	efficient	 manner 	by	 hiding	 underlying	 complexity	of	the	hardware	and	acting	as	a	resource	manager. 	 Why	OS? 	 1.What	if	there	is	no	OS? a.Bulky	 and	 complex	 app.	 (Hardware	 interaction	 code	 must 	be	 in	 app’ s code	base) b.Resource	 exploitation	by	1	App. c.No	memory	protection. 2.What	is	 an	OS	made	up	of? a.Collection	of	system	software. An	operating 	system 	function	 -	 - Access	to 	the	computer 	hardware. 	 -interface	between	 the	user	and	the	computer 	hardware -Resource	management	 (Aka,	Arbitration)	 (memory,	device,	file,	security,	process	etc) -Hides	the	underlying	complexity	of	the	hardware. 	(Aka,	Abstraction) -facilitates 	execution	 of	application 	programs	by	providing	isolation	and	protection. User	 Application 	programs 	 Operating 	system 	 Computer 	hardware 	 The	operating	system	provides	the	means	for	proper	use	of	the	resources	in	the	operation	of	 the	computer 	system. 	 OS	goals	–	 •Maximum	CPU	utilization •Less	process	starvation •Higher	priority	job 	execution Types	 of	operating	 systems	 –	 [MS	DOS,	1981] 	 [ATLAS, 	Manchester 	Univ., 	late	1950s 	–	early	 1960s] 	 -Multiprogramming 	operating 	system 	[THE, 	Dijkstra, 	early	 1960s]-Single	 process	 operating	 system -Batch -processing	operating 	system -Multitasking 	operating 	system -Multi -processing 	operating	system -Distributed 	system -Real	time	OS[CTSS, 	MIT,	early	 1960s] 	 [Windows	NT] 	 [LOCUS ]	 [ATCS] 	 LEC-2: Types of OS CodeHelpSingle	process	OS,	only	1	process	 executes	at	a	time	from	the	ready	queue. 	[Oldest] 	 Batch- processing	OS,	 	 1.Firstly,	user	prepares	his	job	using	punch	cards. 2.Then,	he	submits	the	job	to	the	computer	operator. 3.Operator	collects	the	jobs	from	different	users	and	sort	the	jobs	into	 batches	with similar	needs. 4.Then,	operator	submits	the	batches	to	the	processor	one	by	one. 5.All	the	jobs	of	one	batch	are	executed	together. -Priorities	cannot	be	set,	if	a	job	comes	with	some	higher	priority. -May	lead	to	starvation.	(A	batch	may	take	more	 time	to	complete) -CPU	may	become	idle	in	case	of	I/O	operations. Multiprogramming 	increases 	CPU	utilization	 by	keeping 	multiple 	jobs	(code 	and	data) 	 in	the	memory 	so	that	the	CPU	 always 	has	one	to	execute	in	case	some	job	gets	busy	with	 I/O.	 -Single	CPU -Context	switching	for	processes. -Switch	happens	when	current	process	goes	to	wait	state. -CPU	idle	time	reduced. Multitasking	 is	a	logical 	extension	 of	 multiprogramming. 	 	 -Single	CPU -Able	to	run	more	than	one	task simultaneously. -Context	switching	and	time	sharing	used. -Increases	responsiveness. -CPU	idle	time	is	further	reduced. Multi -processing	OS,	 more	than	1	CPU	in	a	  singl e	computer.	 -Increases	reliability,	1	CPU	fails,	othercan	work -Better	throughput. -Lesser	process	starvation,	(if	1	CPU	isworking	on	some	process,	other	can	beexecuted	on	other	CPU. CodeHelpDistri bute d	OS, 	 RTOS	-OS	manages	 many	b unches	 of	resources,   >=1	CPUs,	 >=1	memory,	 >=1	GPUs,	 etc -Loosely	 connected	 autonomous,   inter connected	 computer node s. -collection	 of	independent,	 networked,   communicating,	 and	physically	 separate   computational	 nodes. -Real	 time	 error	 free,	c omputations   within	 tight-time	boundaries. -Air	Traffic	 control	 system,	 ROBOTS	 etc. CodeHelpLEC-3: Multi-Tasking vs Multi-Threading   Program : A Program is an executable file which contains a certain set of instructions written  to complete the specific job or operation on your computer.  •It’s a compiled code.  Ready to be

Q: What is the main difference between thread context switching and process context switching in an operating system?
A: The main difference between thread context switching and process context switching is that in thread context switching, the operating system saves the current state of a thread and switches to another thread of the same process, whereas in process context switching, the operating system saves the current state of a process and switches to another process by restoring its state. Additionally, thread context switching is faster and preserves CPU's cache state, whereas process context switching is slower and flushes CPU's cache state.
Context: executed. •Stored in Disk Process : Program under execution. R esides in Computer’s primary memory (RAM).  Thread:   •Single sequence stream within a pr ocess. •An independent path of execution in a process. •Light-weight process. •Used to achieve parallelism by dividing a process’s tasks which are independent path of execution. •E.g., Multiple tabs in a browser, text editor (When you are typing in an editor, spell-checking, formatting of text and saving the text are done concurrently by multiplethreads.) Multi-Tasking Multi-Threading   The execution of more than one task  simultaneously is called as multitasking. A process is divided into several different  sub-tasks called as threads, which has its  own path of execution. This concept is  called as multithreading.   Concept of more than 1 processes being context switched. Concept of more than 1 thread. Threads are context switched.  No. of CPU 1.  No. of CP U >= 1. (Better to have more than  1)  Isolation and memory protection  exists.  OS must allocate separate memory and resources to each program that CPU is executing. No isolation and memory prote ction ,  resources are shared among threads of that process.  OS allocates memory to a process; multiple threads of that process share the same memory and resources allocated to the process.  Thread Scheduling:  Threads are scheduled for execution based on their priority. Even though threads are executing within the runtime,  all threads are assigned processor time slices by the operating  system.  Difference between Thread Context Switch ing and Process Context Switch ing:  Thread Context switching Process context switching  OS saves current state of thread & switches  to another thread of same process. OS saves current state of process &  switches to another process by restoring its state.  CodeHelpDoesn ’t includes switching of memory  address space.   (But Program counter, registers & stack are include d.) Includes switching of memory address  space.  Fast switching. Slow switching.  CPU’s cache state is preserved. CPU’s cache state is flushed.  CodeHelpLEC-4: Component s	of	OS 1.Kernel: 	A	kernel 	is	that	part	of	the operating 	system 	which 	interacts 	directly with	 the	hardware 	and																																										performs 	the	most crucial 	tasks. a.Heart 	of	OS/Core 	component b.Very 	first	part	of	OS	to	load	on start -up. 2.User 	space: 	Where 	application 	software runs, 	apps	 don’t 	have	privil eged	access	 to the	 underlying 	hardware.	It	interacts 	with kernel. a.GUI b.CLI A	shell ,	also	known 	as	a	command 	interpreter, 	is	that	part	of	the	operating 	system 	that	receives 	 commands 	from 	the	users 	and	gets	them 	executed. 	 Functions	of	Kernel :	 1.Proc ess	management: a.Scheduli ng	processes	 and	thread s	on	the	CPUs. b.Creating 	&	deleting 	both	user	and	system 	process. c.Suspendi ng	and	resumi ng	processes d.Providing 	mechanism s	for	proc ess	synchronizati on	or	 process  communication. 2.Memory 	management: a.Allocating 	and	deallocating 	mem ory	spac e	as	per	 need. b.Keepi ng	track	 of	which	part	of	mem ory	are	 currentl y	being	used	 and	by  whic h	process. 3.File	management: a.Creating 	and	deleting 	files. b.Creating 	and	deleting 	directories 	to	organize 	files. c.Mapping 	files	into	secondary 	storage. d.Backup	 support 	onto	a	stabl e	storage	 media. 4.I/O	managemen t:	to	manage 	and	control	I/O 	operations 	and	I/O	devices a.Bufferi ng	(data	copy	 betw een	two	devices), 	caching	and	 spooling. i.Spooling 1.Within	differing	speed	 two	jobs. 2.Eg.	Print	spooling	and	mail	spooling. ii.Buffering 1.Within	one	job. 2.Eg.	Youtube	video	buffering iii.Caching 1.Memory	caching,	Web	caching	etc. a.All	functions	are	in	kernel	itself. b.Bulky	in	size. c.Memory	required	to	run	is 	high. d.Less	reliable,	one	module	crashes	 ->	whole	kernel	is	down. e.High	performance	as	communication	is	fast.	(Less	user	mode,	kernel mode	overheads) f.Eg.	Linux,	Unix,	MS -DOS.Types	of	Kernels:

Q: What is the main difference between a monolithic kernel and a microkernel?
A: A monolithic kernel is a single, large piece of software that contains all the necessary code for the operating system, while a microkernel is a smaller kernel that only contains the most essential functions, with other functions being handled by separate modules that run in user space. The microkernel approach allows for better modularity, reliability, and stability, but it can also lead to slower performance and increased overhead due to the need to switch between user and kernel mode.
Context: 1.Monolithic	kernelCodeHelp2.Micro	Kernel a.Only	major	functions	are	in	kernel. i.Memory	mgmt. ii.Process	mgmt. b.File	mgmt.	and	IO	mgmt.	are	in	User -space. c.smaller	in	size. d.More	Reliable e.More	stable f.Performance 	is	slow. g.Overhead	switching	b/w	 user	mode	and	kernel	mode. h.Eg.	L4	Linux,	Symbian	OS,	MINIX	etc. 3. Hybrid 	Kernel: a.Advantag es	of	both	worlds. 	(File	mgmt. 	in	User	 space	and	rest	in	Kernel  space. 	) b.Combine d	approach. c.Speed	and	desi gn	of	mono. d.Modularity 	and	stability 	of	micro. e.Eg.	MacOS, 	Window s	NT/7/10 f.IPC	also	happens 	but	lesser 	overheads 4. Nano/Exo 	kernels… Q.How 	will	communication 	happen 	between 	user	mode	and	kernel 	mode? Ans.	Inter	proc ess	communicati on	(IPC). 1.Two	 processes 	executing 	independently, 	having 	independent 	memory 	space (Memo ry	 protection), 	But	some	m ay	need	to	communicate	to	work. 2.Done 	by	shared 	memory 	and	message 	passing. CodeHelp  LEC-5: System  Calls  How  do apps interact  with  Kernel?  -> using  system  calls.  Eg. Mkdir  laks  - Mkdir indirectly  calls kernel and asked the file mgmt.  module to create  a new  directory.   - Mkdir  is just a wrapper  of actual system  calls.   - Mkdir interacts with  kernel using system  calls.     Eg. Creating a process.   - User  executes  a process.  (User  space)   - Gets  system  call. (US)  - Exec system  call to create a process.  (KS)  - Return to  US.    Transitions  from  US to KS done by software  interrupts.     System  calls are implemented  in C.    A system  call is a mechanism using which  a user program  can request  a service  from  the kernel  for  which it does not have the permission  to perform.   User  programs  typically  do not have  permission to perform  operations  like accessing I/O devices  and  communicating  other  programs.     System Calls  are the only way through which a process can go into kernel mode from user mode.      Types of System Calls :  1) Proc ess Control   a. end, abort   b. load,  execute  c. create process, terminate process   d. get process attributes, set process attributes   e. wait for time   f. wait event, signal event   g. allocate and free memory     2) File Management   a. create file, delete file   b. open, close   c. read, write, reposition   d. get f ile attributes, set file attributes     3) Device Management   a. request device, release device   b. read, write, reposition   c. get device attributes, set device attributes   d. logically attach or detach devices     4) Information  main tenance   a. get time or date, set time or date  b. get system data, set system data  c. get process, file, or device attributes  d. set process, fil e, or device attributes     5) Communication Management   a. create, delete communication connection   b. send, receive messages  c. transfer status information   d. attach or detach remote devices    Examples of Wi ndows & Unix System calls:  Category  Windows Unix       Process Control CreateProcess()   ExitProcess()   WaitForSingleObject()  fork()  exit()  wait()      File Ma nagement  Create File()  ReadFile()  WriteFile()   CloseHandle()   SetFileSecurity() InitlializeSecurityDescriptor() SetSecurityDescriptorGroup()  open ()   read ()  write  ()  close ()   chmod()   umask(   chown()       Device Management  SetConsoleMode ()  ReadConsole()  WriteConsole()  ioctI ()  read()  write( )      Information Management  GetCurrentProcessID()   SetTimer()  Sleep() getpid ()  alarm ()  sleep ()      Communicatio n CreatePipe()   CreateFileMapping()   MapViewOfFile()  pipe ()  shmget ()   mmap()  i.PC	On ii.CPU	 initializes	 itself	 and	looks	 for	a	firmware	 program	 (BIOS)	 stored	 in  BIOS	 Chip	(Basic	 input-ou tput	 system	 chip	 is	a	ROM	 chip	 found	 on  mother	b oard	t hat	allows	t o	access	& 	setup	c omputer	s ystem	 at	most   basic	 level.) 1.In	modern	 PCs,	CPU	 loads	 UEFI	(Unified	 extensible	 firmware   interface) iii.CPU	runs	 the	BIOS	 which	t ests	and	initializes	 system	hardware. Bios  loads

Q: What are the advantages of using a 64-bit operating system over a 32-bit operating system?
A: The advantages of using a 64-bit operating system over a 32-bit operating system include: * Addressable Memory: 64-bit CPUs can address 2^64 memory addresses, which is much larger than the 2^32 memory addresses that 32-bit CPUs can address. * Resource usage: Installing more RAM on a system with a 32-bit OS does not impact performance, but upgrading to a 64-bit version of Windows can improve performance. * Performance: 64-bit processors can perform larger calculations at the same time due to larger registers. * Compatibility: 64-bit CPUs can run both 32-bit and 64-bit OSes, while 32-bit CPUs can only run 32-bit OSes. * Better Graphics performance: 64-bit processors can perform 8-byte graphics calculations, making graphics-intensive apps run faster.
Context: configuration settings.	If something	 is	not	appropriate	 (like	 missing	 RAM)	 error	 is	thrown	 and boot	 process	 is	stopped. This	 is	called	 POST	 (Power	 on	self-te st)	process. (UEFI	can	do	a	lot	more	 than	 just	initialize	 hardware;	 it’s	really	 a	tiny  operating	 system.	 For	example,	 Intel	 CPUs	 have	 the	Intel	M anagement   Engine.	This	 provides	 a	variety	 of	features,	 including	 powering	I ntel’s   Active	 Management	 Technology,	 which	 allows	 for	remote	 management   of	business	 PCs.) iv.BIOS	 will	handoff	 responsibility	 for	booting	 your	 PC	to	your	 OS’s   bootloader. 1.BIOS	 looked	 at	the	MBR	 (master	 boot 	record) ,	a	special	boot sector	at 	the	beginni ng	of	a	disk. 	The	MBR	contains	code	 that loads 	the	r est	of	the 	operating 	system,	known 	as	a	“b ootloader.” The	BIOS 	executes 	the	bootloader, 	which	 takes 	it	from	ther e	and begins	 booting	 the	actual 	operating	 system—W indows 	or	Linux, for	example. In	other 	words, the	B IOS	or	UEFI	examines 	a	storage 	device 	on	your	system	to look	for	a	s mall	program,	either	in 	the	MBR	or	on	an	EFI	system partition, 	and	runs	 it. v. The	bootloader	 is	a	small	 program	 that	 has	the	large	 task	 of	booting	 the rest	o f	the	operating	 system (Boots Ke rnel the n, User S pace).	 Windows	 uses	 a	bootloader	n amed Windows	B oot	Manager	( Bootmgr.exe),	 most	 Linux	 systems	 use	GRUB, and	Macs	 use	something	 called	boot.efiLEC-6: What happens when you turn on your computer? CodeHelpLec-7 : 32-Bit vs 64- Bit OS  1. A 32-bit OS has 32-bit registers, and it can access 2^32 unique memory addresses. i.e., 4GB of physical memory. 2. A 64-bit OS has 64-bit registers, and it can access 2^64 unique memory addresses. i.e., 17,179,869,184 GB of physical memory. 3. 32-bit CPU architecture can process 32 bits of data & information. 4. 64-bit CPU architecture can process 64 bits of data & information. 5. Advantages of 64-bit over the 32-bit operating system: a. Addressable Memory: 32-bit CPU -> 2^32 memory addresses, 64-bit CPU -> 2^64memory addresses. b. Resource usage: Installing more RAM on a system with a 32-bit OS doesn't impact performance. However, upgrade that system with excess RAM to the 64-bit version of Windows, and you'll notice a difference. c. Performance: All calculations take place in the registers. When you’re performing math inyour code, operands are loaded from memory into registers. So, having larger registers allow you to perform larger calculations at the same time.32-bit processor can execute 4 bytes of data in 1 instruction cycle while 64-bit means that processor can execute 8 bytes of data in 1 instruction cycle. (In 1 sec, there could be thousands to billons of instruction cycles depending upon a processor design) d. Compatibility: 64-bit CPU can run both 32-bit and 64-bit OS. While 32-bit CPU can only run 32-bit OS. e. Better Graphics performance: 8-bytes graphics calculations make graphics-intensive appsrun faster. CodeHelpLec-8: Storage Devices Basics  What are the different memory present in the computer system?  1. Register: Smallest unit of storage. It is a part of CPU itself. A register may hold an instruction, a storage address, or any data (such as bit sequence or individual characters). Registers are a type of computer memory used to quickly accept, store, and transfer data and instructions that are being used immediately by the CPU. 2. Cache: Additional memory system that temporarily stores frequently used instructions and data for quicker processing by the CPU. 3. Main Memory: RAM. 4. Secondary Memory: Storage media, on which computer can store data & programs. Comparison  1. Cost : a. Primary storages are costly. b. Registers are most expensive due to expensive semiconductors & labour. c.Secondary storages are cheaper than primary. 2. Access Speed: a. Primary has higher access speed than secondary memory. b. Registers has highest access speed, then comes cache, then main memory. 3. Storage size: a. Secondary has more

Q: What is the main purpose of the registers in the PCB in the context of process management?
A: The main purpose of the registers in the PCB is to store the information of a process, such as process id, program counter, process state, priority, etc. When a process is running and its time slice expires, the current value of process-specific registers would be stored in the PCB, and the process would be swapped out. When the process is scheduled to be run, the register values are read from the PCB and written to the CPU registers. This is the main purpose of the registers in the PCB. Therefore, the answer is (D) The registers in the PCB store information about the process, and their values are used to restore the process context when the process is resumed.
Context: space. 4. Volatility: a. Primary memory is volatile. b. Secondary is non-volatile. CodeHelpLec-9: Introduction to Process  1. What is a program? Compiled code, that is ready to execute. 2. What is a process? Program under execution. 3. How OS creates a process? Converting program into a process. STEPS: a. Load the program & static data into memory.b. Allocate runtime stack. c. Heap memory allocation. d. IO tasks.e. OS handoffs control to main (). 4. Architecture of process: 5. Attributes of process: a. Feature that allows identifying a process uniquely. b. Process table i. All processes are being tracked by OS using a table like data structure. ii. Each entry in that table is process control block (PCB). c. PCB: Stores info/attributes of a process. i. Data structure used for each process, that stores information of a process such as process id, program counter, process state, priority etc. 6. PCB structure: Registers in the PCB, it is a data structure. When a processes is running and it's time slice expires, the current value of process specific registers would be stored in the PCB and the process would be swapped  out. When the process is scheduled to be run, the register values is read from the PCB and written to the CPU registers. This is the main purpose of the registers in the PCB.  CodeHelpLec-10: Process States | Process Queues  1. Process States: As process executes, it changes state. Each process may be in one of the following states. a. New: OS is about to pick the program & convert it into process. OR the process is being created. b. Run: Instructions are being executed; CPU is allocated. c. Waiting: Waiting for IO. d. Ready: The process is in memory, waiting to be assigned to a processor. e. Terminated: The process has finished execution. PCB entry removed from process table. 2. Process Queues: a. Job Queue: i. Processes in new state. ii. Present in secondary memory. iii. Job Schedular (Long term schedular (LTS)) picks process from the pool and loads them into memory for execution. b. Ready Queue: i. Processes in Ready state. ii. Present in main memory. iii. CPU Schedular (Short-term schedular) picks process from ready queue anddispatch it to CPU. c. Waiting Queue: i. Processes in Wait state. 3. Degree of multi-programming: The number of processes in the memory. a. LTS controls degree of multi-programming. 4. Dispatcher: The module of OS that gives control of CPU to a process selected by STS. CodeHelpLEC-11: Swapping | Context-Switching | Orphan process | Zombie process  1. Swapping a. Time- sharing system may have medium term schedular (MTS ). b. Remove processes from memory to reduce degree of multi -programming. c. These removed processes  can be re introduce d into memory, and its e xecution can be con tinued where it left off . This is called Swapping. d. Swap- out and swap- in is done by MTS. e. Swapping is necessary to improve process mix or because a change in  memory requirement s has overcommitted available memory, requiring memory to be freed u p. f. Swapping is a mechanism in which a process can be swapped temporarily out of main memory (or move) to secondary storage (disk) and make that memory available to other processes. At some later time, the system swaps back the process from the secondary storage to main memory. 2. Context -Switching a. Switching the CPU to another process require s performing a state save of the current process and a state restore of a different process. b. When this occurs, the kern el saves the context of the old process in its PCB and loads the saved context of the new process scheduled to r un. c. It is pu re overhead, because the system does no useful work whi le switching. d. Speed varies from machine t o machine, depending on the mem ory speed, the number of registers that must be copied etc. 3. Orphan proce ss a. The process whose parent process ha s been terminated and it is still running. b. Orphan processes are adopted by init process. c. Init is the first process of

